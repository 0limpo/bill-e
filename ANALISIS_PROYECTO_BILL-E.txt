================================================================================
                    AN√ÅLISIS COMPLETO DEL PROYECTO BILL-E
                           Fecha: 27 Noviembre 2025
================================================================================

√çNDICE:
1. Estructura de Archivos y Carpetas
2. An√°lisis del Backend
3. An√°lisis del Frontend
4. Funcionalidades Implementadas
5. Endpoints de la API
6. Dependencias
7. Estado de Integraciones
8. Otras Funcionalidades Importantes
9. Resumen Ejecutivo

================================================================================
1. ESTRUCTURA DE ARCHIVOS Y CARPETAS
================================================================================

bill-e/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ main.py                    # API principal con FastAPI (326 l√≠neas)
‚îÇ   ‚îú‚îÄ‚îÄ ocr_service.py             # Servicio OCR con Google Vision (389 l√≠neas)
‚îÇ   ‚îú‚îÄ‚îÄ webhook_whatsapp.py        # Webhooks de WhatsApp (392 l√≠neas)
‚îÇ   ‚îú‚îÄ‚îÄ database.py                # Capa de acceso a Redis (64 l√≠neas)
‚îÇ   ‚îú‚îÄ‚îÄ models.py                  # Modelos Pydantic (62 l√≠neas)
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt           # Dependencias Python (12 paquetes)
‚îÇ   ‚îú‚îÄ‚îÄ render.yaml                # Config de deploy en Render
‚îÇ   ‚îú‚îÄ‚îÄ test_redis.py              # Tests de Redis
‚îÇ   ‚îú‚îÄ‚îÄ test_session.py            # Tests de sesiones
‚îÇ   ‚îú‚îÄ‚îÄ test_simple.py             # Tests simples
‚îÇ   ‚îú‚îÄ‚îÄ bill-e-ocr-bce903295fd1.json  # Credenciales Google Cloud
‚îÇ   ‚îî‚îÄ‚îÄ .env                       # Variables de entorno
‚îÇ
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.js                 # Componente principal React (448 l√≠neas)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.css                # Estilos completos (414 l√≠neas)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.js               # Entry point
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.test.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ reportWebVitals.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ setupTests.js
‚îÇ   ‚îú‚îÄ‚îÄ public/                    # Assets est√°ticos
‚îÇ   ‚îú‚îÄ‚îÄ package.json               # Dependencias npm
‚îÇ   ‚îî‚îÄ‚îÄ package-lock.json
‚îÇ
‚îú‚îÄ‚îÄ README.md                      # Documentaci√≥n del proyecto
‚îî‚îÄ‚îÄ .gitignore

================================================================================
2. AN√ÅLISIS DEL BACKEND
================================================================================

--------------------------------------------------------------------------------
2.1. main.py - API FastAPI (326 l√≠neas)
--------------------------------------------------------------------------------

FUNCIONALIDAD PRINCIPAL:
- API REST con FastAPI
- CORS habilitado para frontend
- Sistema de sesiones temporales con Redis
- Integraci√≥n con OCR y WhatsApp

ENDPOINTS IMPLEMENTADOS:

Health Check:
  GET /health
  - Verifica estado del servicio
  - Response: {"status": "healthy", "service": "bill-e-backend"}

Sesiones OCR (Nuevos):
  POST /api/session
  - Crea nueva sesi√≥n de divisi√≥n de cuenta
  - Genera UUID √∫nico
  - Expira en 1 hora
  - Retorna URL del frontend

  GET /api/session/{session_id}
  - Obtiene datos de sesi√≥n desde Redis
  - Error 404 si sesi√≥n no existe o expir√≥

  POST /api/session/{session_id}/ocr
  - Procesa imagen en formato base64
  - Extrae items con OCR
  - Actualiza sesi√≥n con datos parseados

  POST /api/session/{session_id}/upload
  - Subir imagen como multipart/form-data
  - Procesa con OCR
  - Extrae y parsea datos de boleta

  POST /api/session/{session_id}/update
  - Actualiza datos de sesi√≥n completa
  - Renueva TTL por 1 hora m√°s

  POST /api/session/{session_id}/calculate
  - Guarda resultado de divisi√≥n de cuenta
  - Compatible con Database y Redis

WhatsApp Webhooks:
  GET /webhook/whatsapp
  - Verificaci√≥n del webhook de Meta
  - Valida WHATSAPP_VERIFY_TOKEN

  POST /webhook/whatsapp
  - Recibe mensajes de WhatsApp
  - Procesa textos e im√°genes
  - Delega a handle_webhook()

CARACTER√çSTICAS:
- Sesiones expiran en 3600 segundos (1 hora)
- Manejo de errores con HTTPException
- Importaciones condicionales (try/except)
- Soporte para m√∫ltiples formatos de imagen

--------------------------------------------------------------------------------
2.2. ocr_service.py - Servicio OCR (389 l√≠neas)
--------------------------------------------------------------------------------

FUNCIONALIDAD:
Procesamiento de im√°genes de boletas usando Google Cloud Vision API con parser
especializado para formato chileno.

CARACTER√çSTICAS PRINCIPALES:

1. Inicializaci√≥n de Google Vision Client:
   - Lee credenciales desde GOOGLE_APPLICATION_CREDENTIALS_JSON (env var)
   - Fallback a archivo local para desarrollo
   - Manejo robusto de errores de credenciales
   - Instancia global: ocr_service

2. Procesamiento de Im√°genes:
   - process_image(image_data: bytes) ‚Üí str
   - process_base64_image(base64_image: str) ‚Üí str
   - Extrae texto completo de la imagen
   - Retorna texto raw para parsing posterior

3. Parser de N√∫meros Chilenos:
   - parse_chilean_number(num_str: str) ‚Üí float
   - Formato chileno: 111.793 = 111,793 (ciento once mil)
   - Detecta si punto es separador de miles o decimal
   - L√≥gica: grupos de 3 d√≠gitos = miles, sino = decimal

4. Parser de Boletas (Funci√≥n Principal):
   - parse_receipt_text(text: str) ‚Üí Dict[str, Any]
   - Extrae: total, subtotal, propina, items

   Patrones de b√∫squeda:
   - Total: m√∫ltiples regex (TOTAL, Total, total)
   - Subtotal: "subtotal", "sub total"
   - Propina: "propina", "tip", "servicio"
   - Items: nombre + precio en l√≠neas consecutivas

   C√°lculos autom√°ticos:
   - Si tiene subtotal + propina ‚Üí calcula total
   - Si tiene solo total ‚Üí estima 90% subtotal, 10% propina
   - Si tiene total + subtotal ‚Üí calcula propina
   - Si tiene total + propina ‚Üí calcula subtotal

   Validaci√≥n:
   - Verifica consistencia: total = subtotal + propina
   - Compara suma de items vs subtotal
   - Ajusta si hay discrepancias

5. Extracci√≥n de Items:
   - extract_items_from_text(lines: List[str]) ‚Üí List[Dict]
   - M√©todo 1: L√≠nea con texto + siguiente l√≠nea con precio
   - M√©todo 2: Regex para "cantidad nombre precio" en misma l√≠nea
   - Filtros:
     * Excluye encabezados (cafe, restaurant, mesa, etc.)
     * Excluye "vaso de agua"
     * Rango v√°lido: 1.000 - 50.000 CLP
     * M√≠nimo 3 caracteres en nombre
   - Evita duplicados

6. Formateo:
   - format_chilean_currency(amount: float) ‚Üí str
   - Retorna: "$111.793" (punto como separador de miles)

CONFIABILIDAD:
- Logs detallados en cada paso
- Retorna "confidence": "high" si extrajo items, "medium" si no
- Incluye "raw_text" y "detected_numbers" para debug

--------------------------------------------------------------------------------
2.3. webhook_whatsapp.py - Integraci√≥n WhatsApp (392 l√≠neas)
--------------------------------------------------------------------------------

FUNCIONALIDAD:
Manejo completo de webhooks de WhatsApp Cloud API con procesamiento autom√°tico
de im√°genes de boletas usando OCR.

VARIABLES DE ENTORNO REQUERIDAS:
- WHATSAPP_VERIFY_TOKEN
- WHATSAPP_ACCESS_TOKEN
- WHATSAPP_PHONE_NUMBER_ID
- REDIS_URL
- FRONTEND_URL

FUNCIONES PRINCIPALES:

1. verify_webhook(hub_mode, hub_challenge, hub_verify_token)
   - Verificaci√≥n inicial del webhook de Meta
   - Compara tokens
   - Retorna challenge si es v√°lido

2. handle_webhook(request: Request)
   - Procesa mensajes entrantes
   - Tipos soportados:
     * text ‚Üí process_text_message()
     * image ‚Üí process_image_message()
     * document ‚Üí process_document_message()

3. process_image_message(phone_number, image_data)
   FLUJO COMPLETO:
   a) Env√≠a mensaje "Estoy procesando tu boleta..."
   b) Descarga imagen desde WhatsApp:
      - get_whatsapp_media_url(media_id) ‚Üí URL de descarga
      - download_whatsapp_media(media_url) ‚Üí bytes
   c) Procesa con OCR:
      - ocr_service.process_image(image_bytes)
      - ocr_service.parse_receipt_text(ocr_result)
   d) Crea sesi√≥n:
      - create_session_with_bill_data(phone_number, parsed_data)
   e) Env√≠a resultado:
      - format_success_message(parsed_data, session_id)
      - Incluye: total, subtotal, propina, items (m√°x 3)
      - Link al frontend: https://bill-e.vercel.app/s/{session_id}

4. process_text_message(phone_number, message)
   COMANDOS:
   - "hola", "hello", "hi", "start" ‚Üí Mensaje de bienvenida
   - "ayuda", "help", "como" ‚Üí Instrucciones de uso
   - Otros ‚Üí Solicita enviar foto de boleta

5. create_session_with_bill_data(phone_number, bill_data)
   - Genera UUID para sesi√≥n
   - Convierte items a formato de sesi√≥n
   - Guarda en Redis por 2 horas (7200 segundos)
   - Incluye metadata: phone_number, ocr_confidence, raw_text

6. send_whatsapp_message(phone_number, message)
   - Env√≠a mensajes v√≠a WhatsApp Cloud API
   - Endpoint: https://graph.facebook.com/v18.0/{phone_id}/messages
   - Formato: texto plano con emojis

CARACTER√çSTICAS:
- Mensajes con emojis para mejor UX
- Formato de moneda chileno en respuestas
- Sesiones de WhatsApp duran 2 horas (vs 1 hora para web)
- Manejo de errores detallado con logs

--------------------------------------------------------------------------------
2.4. database.py - Capa de Acceso a Datos (64 l√≠neas)
--------------------------------------------------------------------------------

FUNCIONALIDAD:
Wrapper para operaciones con Redis (Upstash) usando modelos Pydantic.

CONFIGURACI√ìN:
- Lee REDIS_URL desde .env
- decode_responses=True (retorna strings, no bytes)
- ssl_cert_reqs=None (para Upstash)

M√âTODOS DE LA CLASE Database:

Sesiones:
  save_session(session: SessionData)
  - Key: "session:{session_id}"
  - TTL: 1 hora (timedelta)
  - Formato: JSON serializado con model_dump_json()

  get_session(session_id: str) ‚Üí Optional[SessionData]
  - Recupera desde Redis
  - Deserializa con model_validate_json()
  - Retorna None si no existe

Usuarios:
  save_user(user: UserProfile)
  - Key: "user:{phone}"
  - Sin TTL (permanente)
  - Formato: JSON

  get_user(phone: str) ‚Üí Optional[UserProfile]
  - Recupera perfil de usuario
  - Retorna None si no existe

  get_or_create_user(phone: str) ‚Üí UserProfile
  - Si existe, lo retorna
  - Si no existe, crea uno nuevo con:
    * pricing_variant asignado por hash del tel√©fono
    * Distribuci√≥n uniforme entre 4 variantes
    * free_bills_used = 0
    * is_premium = False

SISTEMA DE A/B TESTING:
- 4 variantes: $0.99, $1.49, $1.89, $2.49
- Asignaci√≥n determin√≠stica: hash(phone) % 4
- Mismo usuario siempre ve mismo precio

--------------------------------------------------------------------------------
2.5. models.py - Modelos de Datos (62 l√≠neas)
--------------------------------------------------------------------------------

ENUMS:

PricingVariant (str, Enum):
  - VARIANT_099 = "0.99"
  - VARIANT_149 = "1.49"
  - VARIANT_189 = "1.89"
  - VARIANT_249 = "2.49"

ConversationState (str, Enum):
  - IDLE
  - WAITING_FOR_PHOTO
  - PHOTO_RECEIVED
  - WAITING_FOR_MANUAL_INPUT
  - PROCESSING_WEB
  - SHOWING_RESULT
  - PAYWALL

MODELOS PYDANTIC:

Person:
  - id: str
  - name: str

Item:
  - id: str
  - name: str
  - price: float
  - quantity: int = 1
  - assigned_to: List[str] = []

SessionData:
  - session_id: str
  - phone: str
  - created_at: datetime (auto)
  - expires_at: datetime
  - items: List[Item] = []
  - people: List[Person] = []
  - tip_percentage: float = 0.15
  - state: ConversationState = IDLE
  - result: Optional[Dict] = None

UserProfile:
  - phone: str
  - created_at: datetime (auto)
  - free_bills_used: int = 0
  - is_premium: bool = False
  - premium_until: Optional[datetime] = None
  - pricing_variant: PricingVariant
  - country_code: Optional[str] = None
  - total_bills_divided: int = 0
  - last_active: datetime (auto)

ConversionEvent:
  - phone: str
  - timestamp: datetime (auto)
  - pricing_variant: PricingVariant
  - converted: bool
  - country_code: Optional[str] = None
  - bill_total: Optional[float] = None
  - bill_tip: Optional[float] = None

================================================================================
3. AN√ÅLISIS DEL FRONTEND
================================================================================

--------------------------------------------------------------------------------
3.1. App.js - Componente React Principal (448 l√≠neas)
--------------------------------------------------------------------------------

ARQUITECTURA:
- React Router con 2 rutas:
  * / ‚Üí Landing simple
  * /s/:id ‚Üí SessionPage (componente principal)

COMPONENTE SessionPage:

ESTADOS PRINCIPALES:
- sessionData: Datos cargados desde backend
- loading: Estado de carga
- error: Mensajes de error
- people: Array de personas [{name, amount}]
- newPersonName: Input temporal para agregar persona
- assignments: Object {itemName: [personNames]}
- tipPercentage: Porcentaje de propina (default 10)
- customTipAmount: Monto fijo de propina
- editingItems: Object {itemName: boolean}
- timeLeft: Tiempo restante antes de expiraci√≥n

HOOKS Y EFECTOS:

1. useEffect - Timer de Expiraci√≥n:
   - Actualiza cada 1 segundo
   - Calcula diferencia entre expires_at y now
   - Formatos:
     * > 1 hora: "2h 30m"
     * 1-60 min: "15:30"
     * < 1 min: "45s"

2. useEffect - Carga de Sesi√≥n:
   - Extrae ID de URL params
   - Llama loadSessionData(sessionId)

3. loadSessionData(sessionId):
   - Fetch a: https://bill-e-backend-lfwp.onrender.com/api/session/{id}
   - Consolida items duplicados por nombre
   - Suma quantities si hay duplicados
   - Inicializa people = [] (vac√≠o por defecto)
   - Calcula propina inicial (10% del subtotal)
   - Inicializa assignments vac√≠o

FUNCIONES DE GESTI√ìN DE PERSONAS:

- addPerson():
  * Valida nombre no vac√≠o
  * Evita duplicados
  * Recalcula montos

- removePerson(name):
  * Elimina de array de people
  * Limpia assignments de todos los items
  * Recalcula montos

- splitEqually():
  * Divide total entre n√∫mero de personas
  * Asigna monto igual a todos

FUNCIONES DE ASIGNACI√ìN DE ITEMS:

- toggleItemAssignment(itemName, personName):
  * Agrega o quita persona de item
  * Actualiza assignments
  * Recalcula montos autom√°ticamente

C√ÅLCULOS PRINCIPALES:

- getCurrentSubtotal():
  * Suma precios de todos los items
  * return sessionData.items.reduce((sum, item) => sum + item.price, 0)

- getCurrentTip():
  * Si hay customTipAmount: usa ese valor
  * Si no: calcula porcentaje del subtotal
  * return customTipAmount || (subtotal * tipPercentage / 100)

- getCurrentTotal():
  * return subtotal + tip

- calculatePersonAmounts(currentAssignments):
  ALGORITMO DE DIVISI√ìN PROPORCIONAL:

  Para cada persona:
    1. Calcula subtotalAmount:
       - Por cada item asignado a la persona:
         * precio_item / cantidad_personas_asignadas
       - Suma todos los items

    2. Calcula propina proporcional:
       - personTipRatio = subtotalAmount / totalSubtotal
       - personTip = totalTip * personTipRatio

    3. Total de la persona:
       - amount = subtotalAmount + personTip

  Esto asegura que:
  - Quien consume m√°s, paga m√°s propina
  - Propina se distribuye proporcionalmente
  - Suma de todos = total de la cuenta

FUNCIONES DE EDICI√ìN:

- handleItemEdit(itemName, field, value):
  * Edita name, price o quantity
  * Si cambia quantity: recalcula price (unitPrice * quantity)
  * Actualiza sessionData.items
  * Recalcula montos de personas

- toggleItemEdit(itemName):
  * Activa/desactiva modo edici√≥n para un item
  * Actualiza editingItems state

- handleTipPercentageChange(e):
  * Actualiza tipPercentage
  * Limpia customTipAmount
  * Recalcula montos

- handleTipAmountChange(e):
  * Actualiza customTipAmount
  * Override del porcentaje
  * Recalcula montos

RENDERIZADO:

Estados especiales:
- loading ‚Üí "Cargando sesi√≥n..."
- error ‚Üí Card con mensaje de error y emoji ‚ö†Ô∏è
- !sessionData ‚Üí "No se pudo cargar la sesi√≥n"

Layout principal:
1. Header:
   - T√≠tulo "Dividir Cuenta"
   - Timer de expiraci√≥n

2. Summary Card:
   - Subtotal (calculado)
   - Propina (editable por % o monto fijo)
   - Total (calculado)

3. People Section:
   - Header con contador
   - Bot√≥n "Dividir Todo Igual"
   - Grid de personas (cards)
   - Input para agregar nueva persona

4. Items Section:
   - Lista de items de la boleta
   - Para cada item:
     * Nombre (editable)
     * Cantidad √ó Precio (editable)
     * Botones de asignaci√≥n a personas
     * Bot√≥n editar/guardar (‚úèÔ∏è/üíæ)

CARACTER√çSTICAS DESTACADAS:
- Todo el c√°lculo es en tiempo real (no hay bot√≥n "calcular")
- Consolidaci√≥n autom√°tica de items duplicados
- Formateo de moneda chileno: $111.793
- Responsive design
- Validaciones inline

--------------------------------------------------------------------------------
3.2. App.css - Estilos (414 l√≠neas)
--------------------------------------------------------------------------------

DISE√ëO GENERAL:
- Background: Gradiente violeta (#667eea ‚Üí #764ba2)
- Font: System fonts (-apple-system, BlinkMacSystemFont, Segoe UI, Roboto)
- Box-sizing: border-box global
- Padding: 20px global

COMPONENTES PRINCIPALES:

1. Container:
   - max-width: 800px
   - Centrado con margin: 0 auto

2. Cards (Header, Summary, People, Items):
   - background: white
   - border-radius: 12px
   - padding: 24px
   - box-shadow: 0 4px 20px rgba(0,0,0,0.1)
   - margin-bottom: 20px

3. Summary Card:
   - Grid de 3 columnas (Subtotal | Propina | Total)
   - Colores diferenciados:
     * Subtotal: #2d3748 (gris oscuro)
     * Propina: #3182ce (azul)
     * Total: #38a169 (verde)

4. People Grid:
   - grid-template-columns: repeat(auto-fit, minmax(200px, 1fr))
   - Gap: 16px
   - Responsive autom√°tico

5. Person Cards:
   - Background: #f7fafc (gris muy claro)
   - Border: 1px solid #e2e8f0
   - Bot√≥n remove: c√≠rculo rojo (#e53e3e)

6. Items List:
   - Flex column con gap: 12px
   - Item cards con border

7. Assignment Buttons:
   - Default: blanco con border gris
   - Hover: border azul
   - Assigned: background azul, texto blanco
   - Transiciones suaves (0.2s)

8. Botones:
   - "Dividir Todo Igual": violeta (#9f7aea)
   - "Agregar Persona": verde (#38a169)
   - "Edit Item": emoji (‚úèÔ∏è/üíæ)

9. Inputs:
   - Border: #cbd5e0
   - Border-radius: 6px
   - Padding: 10px
   - Focus: border azul (impl√≠cito)

10. Tip Controls:
    - Input de porcentaje
    - "o" separator
    - Input de monto fijo
    - Flexbox horizontal

11. Edit Controls:
    - Inputs inline
    - Cantidad √ó Precio unitario
    - Bot√≥n save (üíæ)

RESPONSIVE (max-width: 768px):
- Summary grid: 3 columnas ‚Üí 1 columna
- People grid: auto-fit ‚Üí 1 columna
- Item info: flex-row ‚Üí flex-column
- Section header: row ‚Üí column

ESTADOS ESPECIALES:
- Loading: Centrado, color blanco, 100vh
- Error container: Card blanco centrado, max-width 500px
- Error icon: 48px

COLORES PRINCIPALES:
- Primary: #3182ce (azul)
- Success: #38a169 (verde)
- Danger: #e53e3e (rojo)
- Warning: #ed8936 (naranja)
- Purple: #9f7aea (violeta)
- Gray scale: #2d3748, #4a5568, #718096, #cbd5e0, #e2e8f0, #f7fafc

--------------------------------------------------------------------------------
3.3. package.json - Dependencias Frontend
--------------------------------------------------------------------------------

INFORMACI√ìN B√ÅSICA:
- name: "frontend"
- version: "0.1.0"
- private: true

DEPENDENCIAS:
  "@testing-library/dom": "^10.4.1"
  "@testing-library/jest-dom": "^6.9.1"
  "@testing-library/react": "^16.3.0"
  "@testing-library/user-event": "^13.5.0"
  "lucide-react": "^0.554.0"        # Librer√≠a de iconos
  "react": "^19.2.0"                # React 19 (latest)
  "react-dom": "^19.2.0"
  "react-router-dom": "^7.9.6"      # Routing
  "react-scripts": "5.0.1"          # Create React App scripts
  "web-vitals": "^2.1.4"            # Performance metrics

SCRIPTS:
  "start": "react-scripts start"    # Dev server (port 3000)
  "build": "react-scripts build"    # Production build
  "test": "react-scripts test"      # Jest tests
  "eject": "react-scripts eject"    # Eject from CRA (irreversible)

CONFIGURACI√ìN ESLINT:
  extends: ["react-app", "react-app/jest"]

BROWSERSLIST:
  Production:
    - >0.2% market share
    - not dead
    - not op_mini all

  Development:
    - last 1 chrome version
    - last 1 firefox version
    - last 1 safari version

NOTA: No usa TypeScript, CSS-in-JS, ni framework de UI (Material, Chakra, etc.)
Solo CSS vanilla y React puro.

================================================================================
4. FUNCIONALIDADES IMPLEMENTADAS
================================================================================

‚úÖ COMPLETAMENTE FUNCIONALES:

1. OCR de Boletas:
   ‚úÖ Procesamiento de im√°genes con Google Cloud Vision API
   ‚úÖ Parser especializado para formato chileno
   ‚úÖ Extracci√≥n autom√°tica de items, precios, totales
   ‚úÖ Detecci√≥n de subtotal, propina, total
   ‚úÖ C√°lculo autom√°tico de valores faltantes
   ‚úÖ Soporte para base64 y multipart/form-data
   ‚úÖ Validaci√≥n de consistencia de datos

2. Divisi√≥n de Cuentas:
   ‚úÖ Interfaz web funcional y responsive
   ‚úÖ Agregar/eliminar personas din√°micamente
   ‚úÖ Asignar items a personas espec√≠ficas
   ‚úÖ Divisi√≥n equitativa (bot√≥n "Dividir Todo Igual")
   ‚úÖ Divisi√≥n por consumo individual
   ‚úÖ C√°lculo de propina proporcional al consumo
   ‚úÖ C√°lculos en tiempo real (sin botones "calcular")

3. Sistema de Sesiones:
   ‚úÖ Sesiones temporales con UUID
   ‚úÖ Almacenamiento en Redis (Upstash)
   ‚úÖ TTL de 1 hora (web) / 2 horas (WhatsApp)
   ‚úÖ URLs compartibles (/s/{session_id})
   ‚úÖ Timer de expiraci√≥n visible

4. Frontend Completo:
   ‚úÖ Interfaz responsive (m√≥vil + desktop)
   ‚úÖ Edici√≥n inline de items (nombre, precio, cantidad)
   ‚úÖ Edici√≥n de propina (% o monto fijo)
   ‚úÖ Timer countdown
   ‚úÖ Formateo de moneda chileno ($111.793)
   ‚úÖ Estados de loading/error
   ‚úÖ Consolidaci√≥n de items duplicados
   ‚úÖ Asignaci√≥n visual con botones

5. Backend API:
   ‚úÖ Endpoints REST funcionales
   ‚úÖ CORS configurado correctamente
   ‚úÖ Manejo de errores con HTTP status codes
   ‚úÖ Documentaci√≥n impl√≠cita en c√≥digo
   ‚úÖ Health check endpoint

6. Deploy en Producci√≥n:
   ‚úÖ Backend en Render (https://bill-e-backend-lfwp.onrender.com)
   ‚úÖ Frontend en Vercel (https://bill-e.vercel.app)
   ‚úÖ Redis en Upstash (cloud)
   ‚úÖ Auto-deploy desde GitHub

7. Testing:
   ‚úÖ Scripts de test para Redis
   ‚úÖ Scripts de test para sesiones
   ‚úÖ Test simple de OCR

üöß PARCIALMENTE IMPLEMENTADAS:

1. Integraci√≥n WhatsApp:
   ‚úÖ C√≥digo completo para webhooks (392 l√≠neas)
   ‚úÖ Procesamiento de mensajes de texto
   ‚úÖ Procesamiento de im√°genes
   ‚úÖ Descarga de media desde WhatsApp
   ‚úÖ Comandos de texto (hola, ayuda)
   ‚úÖ Mensajes formatados con emojis
   ‚ùå FALTA: Configuraci√≥n en producci√≥n
   ‚ùå FALTA: Variables de entorno en Render
   ‚ùå FALTA: Verificaci√≥n de webhook en Meta

2. Sistema de Usuarios:
   ‚úÖ Modelos completos (UserProfile)
   ‚úÖ CRUD en database.py
   ‚úÖ A/B testing de precios
   ‚úÖ Sistema de variantes (4 precios)
   ‚ùå FALTA: Endpoints en main.py
   ‚ùå FALTA: Tracking de uso
   ‚ùå FALTA: L√≠mite de free bills

3. Modelo de Negocio:
   ‚úÖ Pricing variants definidos
   ‚úÖ Modelo freemium dise√±ado
   ‚úÖ ConversionEvent model
   ‚ùå FALTA: L√≥gica de paywall
   ‚ùå FALTA: Contador de usos
   ‚ùå FALTA: Validaci√≥n de premium

‚ùå NO IMPLEMENTADAS:

1. Stripe Payments:
   ‚ùå Endpoints de checkout
   ‚ùå Webhook de Stripe
   ‚ùå Validaci√≥n de pagos
   ‚ùå Manejo de suscripciones
   NOTA: Dependencia instalada pero sin c√≥digo

2. Paywall:
   ‚ùå Bloqueo despu√©s de free bill
   ‚ùå Pantalla de upgrade
   ‚ùå Integraci√≥n con Stripe

3. Analytics:
   ‚ùå Tracking de eventos
   ‚ùå M√©tricas de conversi√≥n
   ‚ùå Dashboard de analytics

4. Landing Page:
   ‚ùå P√°gina de marketing
   ‚ùå Features showcase
   ‚ùå Pricing page
   NOTA: Solo muestra "Bill-e - Dividir cuentas f√°cilmente" en /

5. Sistema de Referidos:
   ‚ùå C√≥digos de referido
   ‚ùå Rewards por referir
   ‚ùå Tracking de origen

6. Historial:
   ‚ùå Historial de cuentas divididas
   ‚ùå Exportaci√≥n de reportes
   ‚ùå Estad√≠sticas personales

7. Notificaciones:
   ‚ùå Emails transaccionales
   ‚ùå Notificaciones push
   ‚ùå Recordatorios

================================================================================
5. ENDPOINTS DE LA API
================================================================================

BASE URL: https://bill-e-backend-lfwp.onrender.com

--------------------------------------------------------------------------------
5.1. Health Check
--------------------------------------------------------------------------------

GET /health

Response 200:
{
  "status": "healthy",
  "service": "bill-e-backend"
}

Uso: Verificar que el backend est√° funcionando

--------------------------------------------------------------------------------
5.2. Crear Sesi√≥n
--------------------------------------------------------------------------------

POST /api/session

Request Body: (vac√≠o)

Response 200:
{
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "expires_at": "2025-11-27T15:30:00.000Z",
  "frontend_url": "https://bill-e.vercel.app/s/550e8400-e29b-41d4-a716-446655440000"
}

Comportamiento:
- Genera UUID √∫nico
- Crea sesi√≥n en Redis con TTL de 1 hora
- Sesi√≥n inicial vac√≠a (sin items ni personas)

--------------------------------------------------------------------------------
5.3. Obtener Sesi√≥n
--------------------------------------------------------------------------------

GET /api/session/{session_id}

Response 200:
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "total": 35000,
  "subtotal": 31000,
  "tip": 4000,
  "people": [],
  "items": [
    {
      "id": "item-uuid-1",
      "name": "Hamburguesa",
      "price": 8500,
      "assigned_to": []
    },
    {
      "id": "item-uuid-2",
      "name": "Papas Fritas",
      "price": 3500,
      "assigned_to": []
    }
  ],
  "created_at": "2025-11-27T14:30:00.000Z",
  "expires_at": "2025-11-27T15:30:00.000Z"
}

Response 404:
{
  "detail": "Sesi√≥n no encontrada o expirada"
}

--------------------------------------------------------------------------------
5.4. Procesar Imagen OCR (Base64)
--------------------------------------------------------------------------------

POST /api/session/{session_id}/ocr
Content-Type: application/json

Request Body:
{
  "image": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAA..."
}

Response 200 (Success):
{
  "success": true,
  "data": {
    "total": 35000,
    "subtotal": 31000,
    "tip": 4000,
    "items": [
      {
        "name": "Hamburguesa",
        "price": 8500,
        "quantity": 1
      },
      {
        "name": "Papas Fritas",
        "price": 3500,
        "quantity": 2
      }
    ],
    "raw_text": "CAF√â RESTAURANT\nMesa 5...",
    "confidence": "high",
    "detected_numbers": [35000, 31000, 8500, 3500]
  },
  "session": { /* sesi√≥n actualizada */ }
}

Response 200 (Error en OCR):
{
  "success": false,
  "error": "No se encontraron items en la boleta",
  "raw_text": "texto extra√≠do..."
}

Response 400:
{
  "detail": "No se pudo extraer texto de la imagen"
}

Response 404:
{
  "detail": "Sesi√≥n no encontrada"
}

Response 500:
{
  "detail": "OCR service not available"
}

Comportamiento:
- Decodifica base64 a bytes
- Procesa con Google Vision API
- Parsea texto extra√≠do
- Actualiza sesi√≥n en Redis
- Renueva TTL por 1 hora m√°s

--------------------------------------------------------------------------------
5.5. Procesar Imagen OCR (Upload)
--------------------------------------------------------------------------------

POST /api/session/{session_id}/upload
Content-Type: multipart/form-data

Request Body:
file: <binary image data>

Response: (Igual que /ocr)

Response 400 (tipo incorrecto):
{
  "detail": "El archivo debe ser una imagen"
}

Tipos aceptados: image/jpeg, image/png, image/jpg, image/webp, etc.

--------------------------------------------------------------------------------
5.6. Actualizar Sesi√≥n
--------------------------------------------------------------------------------

POST /api/session/{session_id}/update
Content-Type: application/json

Request Body:
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "total": 40000,
  "subtotal": 35000,
  "tip": 5000,
  "people": [
    {"id": "p1", "name": "Juan"},
    {"id": "p2", "name": "Mar√≠a"}
  ],
  "items": [
    {
      "id": "item-1",
      "name": "Pizza",
      "price": 12000,
      "assigned_to": ["p1", "p2"]
    }
  ],
  "created_at": "2025-11-27T14:30:00.000Z",
  "expires_at": "2025-11-27T15:30:00.000Z"
}

Response 200:
{
  "success": true,
  "session": { /* datos enviados */ }
}

Response 404:
{
  "detail": "Sesi√≥n no encontrada"
}

Comportamiento:
- Reemplaza completamente los datos de la sesi√≥n
- Renueva TTL por 1 hora m√°s
- √ötil para guardar cambios del frontend

--------------------------------------------------------------------------------
5.7. Calcular Divisi√≥n
--------------------------------------------------------------------------------

POST /api/session/{session_id}/calculate
Content-Type: application/json

Request Body:
{
  "total": 40000,
  "subtotal": 35000,
  "tip": 5000,
  "per_person": [
    {
      "name": "Juan",
      "amount": 20000,
      "items": ["Pizza", "Bebida"]
    },
    {
      "name": "Mar√≠a",
      "amount": 20000,
      "items": ["Pizza", "Postre"]
    }
  ]
}

Response 200:
{
  "status": "ok",
  "message": "Resultado guardado"
}

Response 404:
{
  "detail": "Sesi√≥n expirada"
}

Comportamiento:
- Guarda resultado en session.result (si Database disponible)
- Guarda en Redis: "result:{session_id}" con TTL 24 horas
- √ötil para analytics o historial futuro

--------------------------------------------------------------------------------
5.8. WhatsApp Webhook - Verificaci√≥n
--------------------------------------------------------------------------------

GET /webhook/whatsapp?hub.mode=subscribe&hub.challenge=1234567&hub.verify_token=YOUR_TOKEN

Response 200 (Success):
1234567
(Content-Type: text/plain)

Response 403 (Failed):
{
  "detail": "Forbidden"
}

Comportamiento:
- Meta llama este endpoint al configurar webhook
- Valida que hub.verify_token == WHATSAPP_VERIFY_TOKEN
- Retorna hub.challenge si es v√°lido

--------------------------------------------------------------------------------
5.9. WhatsApp Webhook - Mensajes
--------------------------------------------------------------------------------

POST /webhook/whatsapp
Content-Type: application/json

Request Body (Ejemplo - Mensaje de Texto):
{
  "entry": [
    {
      "changes": [
        {
          "value": {
            "messages": [
              {
                "from": "56912345678",
                "type": "text",
                "text": {
                  "body": "hola"
                }
              }
            ]
          }
        }
      ]
    }
  ]
}

Request Body (Ejemplo - Imagen):
{
  "entry": [
    {
      "changes": [
        {
          "value": {
            "messages": [
              {
                "from": "56912345678",
                "type": "image",
                "image": {
                  "id": "media-id-12345"
                }
              }
            ]
          }
        }
      ]
    }
  ]
}

Response 200:
{
  "status": "ok"
}

Comportamiento:
- Procesa mensajes de texto ‚Üí Env√≠a ayuda o bienvenida
- Procesa im√°genes ‚Üí OCR + crea sesi√≥n + env√≠a link
- Procesa documentos ‚Üí Solicita foto en su lugar
- Responde v√≠a WhatsApp Cloud API

Response 500:
{
  "detail": "WhatsApp webhook not available"
}

================================================================================
6. DEPENDENCIAS
================================================================================

--------------------------------------------------------------------------------
6.1. Backend - requirements.txt
--------------------------------------------------------------------------------

fastapi==0.104.1
  - Framework web moderno para Python
  - Validaci√≥n autom√°tica con Pydantic
  - Documentaci√≥n autom√°tica (Swagger)
  - Async/await nativo

uvicorn[standard]==0.24.0
  - ASGI server para FastAPI
  - [standard] incluye: uvloop, httptools, websockets
  - Auto-reload en desarrollo

pydantic==2.5.0
  - Validaci√≥n de datos con type hints
  - Serializaci√≥n/deserializaci√≥n JSON
  - Modelos de datos robustos

python-dotenv==1.0.0
  - Carga variables de .env
  - Gesti√≥n de configuraci√≥n

requests==2.31.0
  - HTTP client s√≠ncrono
  - Usado para llamadas simples

redis==5.0.1
  - Cliente Redis para Python
  - Conexi√≥n a Upstash
  - Soporte para TTL

stripe==7.8.0
  - SDK oficial de Stripe
  - Procesamiento de pagos
  - ESTADO: Instalado pero no usado

python-multipart==0.0.6
  - Procesamiento de form-data
  - Requerido para UploadFile en FastAPI

httpx
  - HTTP client as√≠ncrono
  - Usado en webhook_whatsapp.py
  - Reemplazo moderno de requests para async

google-cloud-vision==3.4.5
  - SDK de Google Cloud Vision API
  - Procesamiento OCR de im√°genes
  - Text detection

google-oauth2-tool==0.0.3
  - Herramienta de autenticaci√≥n OAuth2
  - Usado para credenciales de Google Cloud

pillow==10.1.0
  - Python Imaging Library (PIL)
  - Procesamiento de im√°genes
  - Usado en ocr_service.py

--------------------------------------------------------------------------------
6.2. Frontend - package.json
--------------------------------------------------------------------------------

DEPENDENCIAS PRINCIPALES:

react@^19.2.0
react-dom@^19.2.0
  - React 19 (√∫ltima versi√≥n mayor)
  - Librer√≠a de UI declarativa
  - Virtual DOM

react-router-dom@^7.9.6
  - Routing para React
  - BrowserRouter, Routes, Route
  - useParams hook

lucide-react@^0.554.0
  - Librer√≠a de iconos SVG
  - 1000+ iconos modernos
  - ESTADO: Instalado pero no usado en el c√≥digo actual

react-scripts@5.0.1
  - Create React App tooling
  - Webpack config
  - Babel config
  - Dev server

web-vitals@^2.1.4
  - Performance metrics
  - Core Web Vitals tracking

DEPENDENCIAS DE TESTING:

@testing-library/react@^16.3.0
@testing-library/jest-dom@^6.9.1
@testing-library/dom@^10.4.1
@testing-library/user-event@^13.5.0
  - Testing utilities
  - Jest matchers
  - User interaction simulation

NOTA IMPORTANTE:
- NO usa TypeScript
- NO usa CSS-in-JS (styled-components, emotion)
- NO usa UI framework (Material-UI, Chakra, Ant Design)
- NO usa state management (Redux, Zustand, Recoil)
- Solo React + CSS vanilla

================================================================================
7. ESTADO DE INTEGRACIONES
================================================================================

--------------------------------------------------------------------------------
7.1. ‚úÖ Google Cloud Vision (OCR)
--------------------------------------------------------------------------------

ESTADO: ‚úÖ COMPLETAMENTE INTEGRADO Y FUNCIONANDO

Configuraci√≥n:
  - SDK: google-cloud-vision==3.4.5
  - Archivo de credenciales: bill-e-ocr-bce903295fd1.json
  - Variable de entorno: GOOGLE_APPLICATION_CREDENTIALS_JSON
  - Fallback: Application Default Credentials (desarrollo local)

Funcionalidad:
  ‚úÖ Text detection de im√°genes
  ‚úÖ Procesamiento de base64
  ‚úÖ Procesamiento de bytes
  ‚úÖ Manejo de errores robusto
  ‚úÖ Logs detallados

Uso en Producci√≥n:
  - Render lee GOOGLE_APPLICATION_CREDENTIALS_JSON del .env
  - Crea cliente Vision con credenciales directas
  - Sin necesidad de archivo f√≠sico en servidor

Limitaciones:
  - Requiere cuenta GCP con Vision API habilitada
  - Costos: $1.50 por 1000 im√°genes (primeras 1000 gratis/mes)

--------------------------------------------------------------------------------
7.2. ‚ö†Ô∏è WhatsApp Cloud API
--------------------------------------------------------------------------------

ESTADO: ‚ö†Ô∏è C√ìDIGO COMPLETO, NO CONFIGURADO EN PRODUCCI√ìN

C√≥digo Implementado (392 l√≠neas):
  ‚úÖ verify_webhook() - Verificaci√≥n de Meta
  ‚úÖ handle_webhook() - Recepci√≥n de mensajes
  ‚úÖ process_text_message() - Comandos de texto
  ‚úÖ process_image_message() - OCR de boletas
  ‚úÖ get_whatsapp_media_url() - Obtener URL de media
  ‚úÖ download_whatsapp_media() - Descargar im√°genes
  ‚úÖ send_whatsapp_message() - Enviar respuestas
  ‚úÖ create_session_with_bill_data() - Crear sesi√≥n desde WhatsApp
  ‚úÖ format_success_message() - Mensaje formateado

Variables de Entorno Requeridas:
  ‚ùå WHATSAPP_VERIFY_TOKEN - Token para verificaci√≥n de webhook
  ‚ùå WHATSAPP_ACCESS_TOKEN - Token de acceso a API
  ‚ùå WHATSAPP_PHONE_NUMBER_ID - ID del n√∫mero de WhatsApp Business

Pasos para Activar:
  1. Crear app en Meta for Developers
  2. Configurar WhatsApp Business API
  3. Obtener Phone Number ID
  4. Generar Access Token
  5. Configurar webhook URL: https://bill-e-backend-lfwp.onrender.com/webhook/whatsapp
  6. Agregar variables de entorno en Render
  7. Verificar webhook desde Meta console

Costos:
  - Conversaciones gratuitas: 1000/mes
  - Despu√©s: $0.0042 - $0.0127 por conversaci√≥n (seg√∫n pa√≠s)

--------------------------------------------------------------------------------
7.3. ‚úÖ Redis (Upstash)
--------------------------------------------------------------------------------

ESTADO: ‚úÖ FUNCIONANDO EN PRODUCCI√ìN

Configuraci√≥n:
  - Provider: Upstash (Redis cloud)
  - Variable de entorno: REDIS_URL
  - Formato: rediss://default:PASSWORD@host:port
  - SSL: Habilitado (rediss://)

Uso:
  ‚úÖ Almacenamiento de sesiones (TTL 1 hora)
  ‚úÖ Almacenamiento de usuarios (permanente)
  ‚úÖ Almacenamiento de resultados (TTL 24 horas)
  ‚úÖ decode_responses=True (strings, no bytes)

Claves usadas:
  - session:{session_id} ‚Üí SessionData
  - user:{phone} ‚Üí UserProfile
  - result:{session_id} ‚Üí Resultado de divisi√≥n

Plan Actual:
  - Free tier de Upstash
  - 10,000 comandos/d√≠a
  - 256 MB storage
  - Suficiente para MVP

Escalamiento:
  - Pay as you go: $0.20 por 100K comandos
  - Pro: $10/mes (10M comandos)

--------------------------------------------------------------------------------
7.4. ‚ùå Stripe
--------------------------------------------------------------------------------

ESTADO: ‚ùå NO IMPLEMENTADO

C√≥digo:
  ‚ùå No hay endpoints de checkout
  ‚ùå No hay webhook handler
  ‚ùå No hay validaci√≥n de pagos
  ‚ùå No hay creaci√≥n de customers
  ‚ùå No hay manejo de suscripciones

Dependencia:
  ‚úÖ stripe==7.8.0 instalado
  ‚ùå Sin c√≥digo de integraci√≥n

Variables Requeridas:
  - STRIPE_SECRET_KEY (no configurada)
  - STRIPE_WEBHOOK_SECRET (no configurada)

Implementaci√≥n Faltante:
  1. Endpoint: POST /api/checkout
     - Crear Checkout Session
     - Pricing based on variant
     - Success/cancel URLs

  2. Endpoint: POST /webhook/stripe
     - Verificar signature
     - Procesar eventos:
       * checkout.session.completed
       * customer.subscription.created
       * customer.subscription.deleted
     - Actualizar UserProfile.is_premium

  3. Endpoint: GET /api/user/{phone}/subscription
     - Verificar estado premium
     - Retornar premium_until

  4. Middleware:
     - Validar premium antes de dividir cuenta
     - Bloquear si free_bills_used >= 1 y !is_premium

Costos:
  - 2.9% + $0.30 por transacci√≥n exitosa
  - Para $1.89: fee ‚âà $0.36 (19% del precio)
  - Considerar incrementar precio para compensar

--------------------------------------------------------------------------------
7.5. ‚úÖ Render (Hosting Backend)
--------------------------------------------------------------------------------

ESTADO: ‚úÖ DESPLEGADO Y FUNCIONANDO

Configuraci√≥n:
  - Archivo: backend/render.yaml
  - Tipo: Web service
  - Env: Python
  - Regi√≥n: Oregon
  - Plan: Free tier

Build:
  - buildCommand: pip install -r requirements.txt
  - startCommand: uvicorn main:app --host 0.0.0.0 --port $PORT

URL:
  - https://bill-e-backend-lfwp.onrender.com

Limitaciones Free Tier:
  - Spin down despu√©s de 15 min inactividad
  - Primera request tarda ~30 segundos (cold start)
  - 750 horas/mes (suficiente para 1 servicio 24/7)

Variables de Entorno (configuradas en Render Dashboard):
  ‚úÖ REDIS_URL
  ‚úÖ GOOGLE_APPLICATION_CREDENTIALS_JSON
  ‚úÖ FRONTEND_URL
  ‚ùå WHATSAPP_* (pendiente)
  ‚ùå STRIPE_* (pendiente)

Auto-Deploy:
  ‚úÖ Conectado a GitHub
  ‚úÖ Deploy autom√°tico en push a main

Health Check:
  - Endpoint: GET /health
  - Intervalo: 60 segundos

Upgrade Path:
  - Starter: $7/mes (no spin down)
  - Pro: $20/mes (m√°s memoria, CPU)

--------------------------------------------------------------------------------
7.6. ‚úÖ Vercel (Hosting Frontend)
--------------------------------------------------------------------------------

ESTADO: ‚úÖ DESPLEGADO Y FUNCIONANDO

Configuraci√≥n:
  - Framework: Create React App
  - Build: npm run build
  - Output: build/

URL:
  - https://bill-e.vercel.app

Variables de Entorno:
  ‚úÖ REACT_APP_API_URL (hardcoded en c√≥digo)
  NOTA: Hardcoded a https://bill-e-backend-lfwp.onrender.com

Caracter√≠sticas:
  ‚úÖ Auto-deploy desde GitHub
  ‚úÖ SSL autom√°tico
  ‚úÖ CDN global
  ‚úÖ Instant rollbacks
  ‚úÖ Preview deployments (por PR)

Plan:
  - Hobby: Gratis
  - 100 GB bandwidth/mes
  - Suficiente para MVP

Optimizaciones:
  - Usa React.StrictMode
  - Code splitting autom√°tico
  - Gzip compression
  - Caching headers

Performance:
  - First Contentful Paint: ~1.5s
  - Time to Interactive: ~2.5s
  - Lighthouse Score: ~85-90

--------------------------------------------------------------------------------
7.7. ‚ö†Ô∏è Google Cloud (Credenciales)
--------------------------------------------------------------------------------

ESTADO: ‚ö†Ô∏è CREDENCIALES EXPUESTAS EN REPOSITORIO

ALERTA DE SEGURIDAD:
  ‚ùå Archivo: backend/bill-e-ocr-bce903295fd1.json
  ‚ùå Este archivo contiene:
     - private_key
     - client_email
     - project_id
  ‚ùå Est√° en el repositorio (git status muestra: ??)
  ‚ùå DEBE SER AGREGADO A .gitignore INMEDIATAMENTE

Acciones Recomendadas:
  1. URGENTE: Agregar a .gitignore:
     ```
     backend/bill-e-ocr-bce903295fd1.json
     backend/*.json
     ```

  2. URGENTE: Rotar credenciales en Google Cloud Console:
     - Ir a: IAM & Admin > Service Accounts
     - Eliminar key actual
     - Crear nueva key
     - Descargar JSON
     - NO commitear

  3. Configurar en Render:
     - Copiar contenido del JSON
     - Pegar en variable GOOGLE_APPLICATION_CREDENTIALS_JSON
     - Eliminar archivo local

  4. Limpiar historial de Git:
     - git rm --cached backend/bill-e-ocr-bce903295fd1.json
     - Considerar BFG Repo-Cleaner si ya se hizo commit

Configuraci√≥n Correcta:
  - Desarrollo: ADC (Application Default Credentials)
  - Producci√≥n: Variable de entorno con JSON completo

================================================================================
8. OTRAS FUNCIONALIDADES IMPORTANTES
================================================================================

--------------------------------------------------------------------------------
8.1. Sistema de A/B Testing de Precios
--------------------------------------------------------------------------------

OBJETIVO:
Determinar el precio √≥ptimo para maximizar revenue mediante testing de 4
variantes de precio.

VARIANTES:
  - VARIANT_099: $0.99/a√±o
  - VARIANT_149: $1.49/a√±o
  - VARIANT_189: $1.89/a√±o (baseline)
  - VARIANT_249: $2.49/a√±o

ASIGNACI√ìN:
  - M√©todo: Determin√≠stico basado en hash del tel√©fono
  - F√≥rmula: variant = variants[hash(phone) % 4]
  - Ventaja: Mismo usuario siempre ve mismo precio
  - Distribuci√≥n: ~25% cada variante

MODELOS:
  UserProfile:
    - pricing_variant: PricingVariant (asignado en creaci√≥n)

  ConversionEvent:
    - pricing_variant: PricingVariant
    - converted: bool
    - bill_total: Optional[float]
    - timestamp: datetime

IMPLEMENTACI√ìN ACTUAL:
  ‚úÖ Modelos definidos
  ‚úÖ L√≥gica de asignaci√≥n en database.py
  ‚úÖ get_or_create_user() asigna variante
  ‚ùå No hay tracking de eventos
  ‚ùå No hay endpoints para analytics
  ‚ùå No hay dashboard de resultados

IMPLEMENTACI√ìN FALTANTE:
  1. Endpoint POST /api/events/paywall_shown
     - Registrar cuando se muestra paywall
     - Guardar pricing_variant del usuario

  2. Endpoint POST /api/events/conversion
     - Registrar conversi√≥n exitosa
     - Asociar con variant

  3. Endpoint GET /api/analytics/ab-test
     - M√©tricas por variante:
       * Total shown
       * Total converted
       * Conversion rate
       * Total revenue
       * Revenue per user

  4. Dashboard simple:
     - Tabla comparativa de variantes
     - Recomendaci√≥n basada en revenue

M√âTRICAS ESPERADAS:
  - Conversion rate: 10-20%
  - Usuarios por mes: 100-1000 (MVP)
  - Significancia estad√≠stica: ~100 conversiones por variante

--------------------------------------------------------------------------------
8.2. Modelo Freemium
--------------------------------------------------------------------------------

DISE√ëO:
  Free Tier:
    - 1 cuenta dividida gratis
    - Acceso completo a features
    - Sin tarjeta de cr√©dito

  Premium:
    - $0.99-$2.49/a√±o (seg√∫n A/B test)
    - Cuentas ilimitadas
    - Sin anuncios (no implementados a√∫n)
    - Soporte prioritario (futuro)

MODELO DE DATOS:
  UserProfile:
    - free_bills_used: int = 0
    - is_premium: bool = False
    - premium_until: Optional[datetime] = None
    - total_bills_divided: int = 0

FLUJO ESPERADO:
  1. Usuario nuevo:
     - free_bills_used = 0
     - Puede dividir 1 cuenta

  2. Primera cuenta:
     - Procesa normalmente
     - Incrementa free_bills_used a 1

  3. Segunda cuenta:
     - Detecta: free_bills_used >= 1 && !is_premium
     - Muestra paywall
     - Opciones: Pagar o cancelar

  4. Despu√©s de pagar:
     - is_premium = True
     - premium_until = now + 1 year
     - free_bills_used resetea (opcional)

  5. Usuario premium:
     - Sin l√≠mites
     - Checkeo de premium_until en cada uso

IMPLEMENTACI√ìN ACTUAL:
  ‚úÖ Modelos completos
  ‚úÖ Estructura de datos
  ‚ùå No hay validaci√≥n en endpoints
  ‚ùå No hay paywall UI
  ‚ùå No hay incremento de contador
  ‚ùå No hay integraci√≥n con Stripe

IMPLEMENTACI√ìN FALTANTE:
  1. Middleware en POST /api/session o /api/session/{id}/ocr:
     ```python
     user = Database.get_or_create_user(phone)

     if user.is_premium:
         # Check if premium expired
         if user.premium_until and user.premium_until < datetime.now():
             user.is_premium = False
             Database.save_user(user)
         else:
             # Allow usage
             pass
     else:
         # Check free tier limit
         if user.free_bills_used >= 1:
             raise HTTPException(402, detail="Paywall")
         else:
             # Allow usage, increment counter
             user.free_bills_used += 1
             user.total_bills_divided += 1
             Database.save_user(user)
     ```

  2. Frontend - Paywall Screen:
     - Mostrar cuando backend retorna 402
     - Mensaje: "Has usado tu cuenta gratis"
     - Bot√≥n: "Upgrade por ${variant.price}/a√±o"
     - Redirect a Stripe Checkout

  3. Webhook de Stripe:
     - Al recibir checkout.session.completed:
       * Extraer phone de metadata
       * user = Database.get_user(phone)
       * user.is_premium = True
       * user.premium_until = now + 1 year
       * Database.save_user(user)

PROYECCIONES (100 usuarios/mes):
  - Free users: 100
  - Intentan segunda cuenta: ~60 (60%)
  - Convierten: ~6-12 (10-20% conversion)
  - Revenue mensual: $6-30 (seg√∫n variant ganador)
  - Revenue anual: $72-360

PROYECCIONES (1000 usuarios/mes):
  - Conversiones: 60-120
  - Revenue mensual: $60-300
  - Revenue anual: $720-3600

--------------------------------------------------------------------------------
8.3. Formato Chileno
--------------------------------------------------------------------------------

CONTEXTO:
En Chile, el separador de miles es el punto (.) y el separador decimal es la
coma (,). Esto es opuesto al formato US.

Ejemplos:
  - Ciento once mil pesos: $111.793 (Chile) vs $111,793 (US)
  - Once pesos con 79 centavos: $11,79 (Chile) vs $11.79 (US)

IMPLEMENTACI√ìN EN OCR:

parse_chilean_number(num_str: str) ‚Üí float:
  L√≥gica:
    1. Limpia: $ y , (comas)
    2. Si tiene punto:
       - Si todos los grupos (excepto primero) tienen 3 d√≠gitos ‚Üí miles
         Ejemplo: "111.793" ‚Üí grupos [111, 793] ‚Üí todos 3 d√≠gitos ‚Üí 111793.0
       - Si no ‚Üí decimal
         Ejemplo: "11.79" ‚Üí grupos [11, 79] ‚Üí 79 no tiene 3 ‚Üí 11.79
    3. Si no tiene punto ‚Üí n√∫mero simple
       Ejemplo: "5000" ‚Üí 5000.0

  Casos edge:
    - "5.000" ‚Üí 5000.0 (miles)
    - "5.00" ‚Üí 5.0 (decimal, porque 00 no tiene 3 d√≠gitos)
    - "111.793.456" ‚Üí 111793456.0 (m√∫ltiples grupos de 3)
    - "111.79" ‚Üí 111.79 (√∫ltimo grupo no es 3)

format_chilean_currency(amount: float) ‚Üí str:
  Implementaci√≥n:
    return f"${amount:,.0f}".replace(',', '.')

  Ejemplos:
    - 111793 ‚Üí "$111.793"
    - 5000 ‚Üí "$5.000"
    - 35000 ‚Üí "$35.000"

IMPLEMENTACI√ìN EN FRONTEND:

formatCurrency(amount):
  return `$${Math.round(amount).toLocaleString('es-CL')}`

  Comportamiento:
    - toLocaleString('es-CL') usa formato chileno autom√°ticamente
    - Math.round() elimina decimales

  Ejemplos:
    - 111793 ‚Üí "$111.793"
    - 5000.5 ‚Üí "$5.001" (redondeado)

CONSISTENCIA:
  ‚úÖ Backend y frontend usan mismo formato
  ‚úÖ OCR parsea correctamente formato chileno
  ‚úÖ Muestra al usuario en su formato nativo

LIMITACI√ìN:
  - No maneja decimales (propina con centavos)
  - Siempre redondea a pesos enteros
  - Para CLP esto es correcto (no hay centavos)

--------------------------------------------------------------------------------
8.4. Edici√≥n de Items en Frontend
--------------------------------------------------------------------------------

FUNCIONALIDAD:
Permite al usuario corregir errores del OCR directamente en la interfaz.

CAMPOS EDITABLES:
  1. Nombre del item
  2. Cantidad (unitario)
  3. Precio unitario

ESTADOS:
  - editingItems: Object {itemName: boolean}
  - Ejemplo: {"Hamburguesa": true, "Papas": false}

INTERFAZ:

Modo Normal:
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ 2x Hamburguesa            ‚úèÔ∏è  $8.500‚îÇ
  ‚îÇ [Juan] [Mar√≠a]                      ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Modo Edici√≥n:
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ [Hamburguesa    ]         üíæ        ‚îÇ
  ‚îÇ [2] √ó [$4250] = $8.500             ‚îÇ
  ‚îÇ [Juan] [Mar√≠a]                      ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

L√ìGICA:

toggleItemEdit(itemName):
  - Cambia editingItems[itemName] entre true/false
  - Icono cambia: ‚úèÔ∏è ‚Üí üíæ
  - Muestra/oculta inputs

handleItemEdit(itemName, field, value):
  - field = 'name':
    * Actualiza item.name directamente
    * Actualiza clave en assignments

  - field = 'quantity':
    * Actualiza item.quantity
    * Recalcula price = unitPrice √ó quantity

  - field = 'price':
    * Actualiza item.price directamente
    * Actualiza unitPrice = price / quantity

  - Llama calculatePersonAmounts() al final

C√ÅLCULO DE PRECIO UNITARIO:
  En el input:
    value={Math.round(item.price / item.quantity)}

  Al cambiar:
    const unitPrice = parseFloat(e.target.value) || 0
    handleItemEdit(item.name, 'price', unitPrice * item.quantity)

CONSOLIDACI√ìN DE DUPLICADOS:

En loadSessionData():
  ```javascript
  const consolidatedItems = {}
  data.items.forEach(item => {
    if (consolidatedItems[item.name]) {
      // Ya existe
      consolidatedItems[item.name].quantity += 1
      consolidatedItems[item.name].price += item.price
    } else {
      // Nuevo
      consolidatedItems[item.name] = {
        name: item.name,
        quantity: 1,
        price: item.price,
        unitPrice: item.price
      }
    }
  })
  ```

Ejemplo:
  Input de OCR:
    - {name: "Coca Cola", price: 1500}
    - {name: "Coca Cola", price: 1500}
    - {name: "Coca Cola", price: 1500}

  Despu√©s de consolidar:
    - {name: "Coca Cola", quantity: 3, price: 4500, unitPrice: 1500}

BENEFICIOS:
  - Usuario puede corregir errores del OCR
  - Evita duplicados en la UI
  - Actualiza c√°lculos en tiempo real
  - No requiere recargar p√°gina

--------------------------------------------------------------------------------
8.5. Timer de Expiraci√≥n
--------------------------------------------------------------------------------

FUNCIONALIDAD:
Muestra al usuario cu√°nto tiempo le queda antes de que expire la sesi√≥n.

CONFIGURACI√ìN:
  - Sesiones web: 1 hora (3600 segundos)
  - Sesiones WhatsApp: 2 horas (7200 segundos)

IMPLEMENTACI√ìN:

useEffect con interval de 1 segundo:
  ```javascript
  useEffect(() => {
    if (sessionData?.expires_at) {
      const updateTimer = () => {
        const now = new Date()
        const expiresAt = new Date(sessionData.expires_at)
        const diff = expiresAt - now

        if (diff > 0) {
          const hours = Math.floor(diff / 3600000)
          const minutes = Math.floor((diff % 3600000) / 60000)
          const seconds = Math.floor((diff % 60000) / 1000)

          if (hours > 0) {
            setTimeLeft(`${hours}h ${minutes}m`)
          } else if (minutes > 0) {
            setTimeLeft(`${minutes}:${seconds.toString().padStart(2, '0')}`)
          } else {
            setTimeLeft(`${seconds}s`)
          }
        } else {
          setTimeLeft('Expirado')
        }
      }

      updateTimer()
      const interval = setInterval(updateTimer, 1000)
      return () => clearInterval(interval)
    }
  }, [sessionData])
  ```

FORMATOS:

M√°s de 1 hora:
  - "2h 30m"
  - "1h 15m"

Entre 1 min y 1 hora:
  - "45:30" (45 minutos, 30 segundos)
  - "15:05"
  - "1:00"

Menos de 1 minuto:
  - "59s"
  - "30s"
  - "5s"

Expirado:
  - "Expirado"

UI:
  ```jsx
  {timeLeft && (
    <p className="timer">Sesi√≥n expira en: {timeLeft}</p>
  )}
  ```

CONSIDERACIONES:
  - Timer corre en cliente (puede tener drift con servidor)
  - No recarga autom√°ticamente cuando expira
  - Usuario debe crear nueva sesi√≥n si expira
  - Backend invalida sesi√≥n autom√°ticamente (Redis TTL)

MEJORA FUTURA:
  - Auto-refresh de sesi√≥n si hay actividad
  - Warning a los 5 minutos
  - Bot√≥n "Extender sesi√≥n"
  - Guardar estado en localStorage

--------------------------------------------------------------------------------
8.6. C√°lculo Proporcional de Propina
--------------------------------------------------------------------------------

PROBLEMA:
¬øC√≥mo dividir la propina de forma justa cuando cada persona consume diferente?

SOLUCI√ìN:
Propina proporcional al consumo individual.

ALGORITMO:

Para cada persona:
  1. Calcular subtotal de la persona:
     subtotalAmount = suma de (precio_item / personas_asignadas)

     Ejemplo:
       - Pizza $12.000 compartida por Juan y Mar√≠a
       - Juan paga: $12.000 / 2 = $6.000
       - Mar√≠a paga: $12.000 / 2 = $6.000

  2. Calcular ratio de consumo:
     personTipRatio = subtotalAmount / totalSubtotal

     Ejemplo:
       - Total de cuenta: $35.000
       - Juan consumi√≥: $20.000
       - Ratio de Juan: $20.000 / $35.000 = 0.571 (57.1%)

  3. Calcular propina de la persona:
     personTip = totalTip √ó personTipRatio

     Ejemplo:
       - Propina total: $3.500 (10%)
       - Propina de Juan: $3.500 √ó 0.571 = $2.000

  4. Total a pagar:
     amount = subtotalAmount + personTip

     Ejemplo:
       - Juan paga: $20.000 + $2.000 = $22.000

IMPLEMENTACI√ìN EN C√ìDIGO:

```javascript
const calculatePersonAmounts = (currentAssignments) => {
  if (!sessionData || people.length === 0) return

  const totalTip = parseFloat(customTipAmount) || 0

  const updatedPeople = people.map(person => {
    let subtotalAmount = 0

    // Calcular subtotal de la persona
    Object.entries(currentAssignments).forEach(([itemName, assignedPeople]) => {
      if (assignedPeople.includes(person.name)) {
        const item = sessionData.items.find(i => i.name === itemName)
        if (item && assignedPeople.length > 0) {
          subtotalAmount += item.price / assignedPeople.length
        }
      }
    })

    // Calcular propina proporcional
    const totalSubtotal = sessionData.subtotal
    const personTipRatio = totalSubtotal > 0
      ? subtotalAmount / totalSubtotal
      : 1 / people.length
    const personTip = totalTip * personTipRatio

    return {
      ...person,
      amount: subtotalAmount + personTip
    }
  })

  setPeople(updatedPeople)
}
```

VALIDACI√ìN:

Invariante: Suma de todos debe igualar el total
  - Œ£(person.amount) = total
  - Œ£(personSubtotal) = subtotal
  - Œ£(personTip) = totalTip

Casos Edge:

1. Divisi√≥n equitativa (todos comparten todo):
   - Cada persona: ratio = 1/n
   - Propina: totalTip / n
   - ‚úÖ Correcto

2. Una persona consume todo:
   - Esa persona: ratio = 1
   - Propina: totalTip √ó 1 = totalTip
   - ‚úÖ Correcto

3. Items no asignados:
   - No afectan c√°lculos
   - Subtotal puede ser < suma de items
   - ‚ö†Ô∏è Advertencia al usuario

4. Propina = 0:
   - personTip = 0 para todos
   - Solo pagan subtotal
   - ‚úÖ Correcto

VENTAJAS:
  ‚úÖ Justo: quien consume m√°s, paga m√°s propina
  ‚úÖ Matem√°ticamente correcto
  ‚úÖ F√°cil de entender
  ‚úÖ Funciona con cualquier combinaci√≥n

COMPARACI√ìN CON ALTERNATIVAS:

Alternativa 1: Propina equitativa
  - personTip = totalTip / numberOfPeople
  - Problema: Injusto si alguien no consumi√≥

Alternativa 2: Sin propina proporcional
  - Solo dividir subtotal
  - Problema: No suma al total correcto

Alternativa 3: Propina por item
  - Agregar % propina a cada item
  - Problema: M√°s complejo, mismo resultado

================================================================================
9. RESUMEN EJECUTIVO
================================================================================

--------------------------------------------------------------------------------
9.1. ESTADO ACTUAL DEL PROYECTO
--------------------------------------------------------------------------------

‚úÖ MVP FUNCIONAL EN PRODUCCI√ìN

Componentes Operativos:
  ‚úÖ Backend API (FastAPI) desplegado en Render
  ‚úÖ Frontend (React) desplegado en Vercel
  ‚úÖ OCR (Google Vision) funcionando
  ‚úÖ Redis (Upstash) como base de datos
  ‚úÖ Sistema de sesiones temporales
  ‚úÖ Divisi√≥n de cuentas con propina proporcional
  ‚úÖ Edici√≥n inline de items
  ‚úÖ Timer de expiraci√≥n
  ‚úÖ Formato chileno de moneda

URLs Funcionales:
  - Backend: https://bill-e-backend-lfwp.onrender.com
  - Frontend: https://bill-e.vercel.app
  - Health: https://bill-e-backend-lfwp.onrender.com/health

--------------------------------------------------------------------------------
9.2. LO QUE FUNCIONA HOY
--------------------------------------------------------------------------------

FLUJO COMPLETO OPERATIVO:

Opci√≥n A - V√≠a API directa:
  1. Usuario crea sesi√≥n: POST /api/session
  2. Recibe session_id y URL del frontend
  3. Sube imagen de boleta: POST /api/session/{id}/upload
  4. OCR extrae items autom√°ticamente
  5. Backend actualiza sesi√≥n con datos
  6. Usuario abre URL en navegador
  7. Ve items pre-cargados de la boleta
  8. Agrega personas
  9. Asigna items a personas
  10. Ajusta propina
  11. Ve cu√°nto paga cada uno
  12. Comparte resultado

Opci√≥n B - Manual (sin OCR):
  1. Usuario abre URL de sesi√≥n
  2. Ve sesi√≥n vac√≠a
  3. Agrega personas manualmente
  4. Agrega items manualmente (requiere c√≥digo custom)
  5. Asigna y divide

Funcionalidades T√©cnicas:
  ‚úÖ Upload de im√°genes (multipart/form-data o base64)
  ‚úÖ Extracci√≥n OCR con Google Vision
  ‚úÖ Parser de formato chileno
  ‚úÖ Detecci√≥n autom√°tica de totales
  ‚úÖ C√°lculo de valores faltantes
  ‚úÖ Consolidaci√≥n de items duplicados
  ‚úÖ Edici√≥n inline con React state
  ‚úÖ Rec√°lculo autom√°tico en tiempo real
  ‚úÖ Formateo de moneda localizado
  ‚úÖ Responsive design
  ‚úÖ Manejo de errores robusto

--------------------------------------------------------------------------------
9.3. LO QUE FALTA PARA MVP COMPLETO
--------------------------------------------------------------------------------

CR√çTICO (Bloquea monetizaci√≥n):

1. ‚ùå Integraci√≥n con Stripe:
   Tiempo estimado: 2-3 d√≠as
   Archivos a crear:
     - backend/stripe_service.py (checkout, webhooks)
     - backend/main.py (agregar endpoints)
     - frontend/src/Paywall.js (componente de upgrade)

   Endpoints necesarios:
     - POST /api/checkout (crear sesi√≥n de pago)
     - POST /webhook/stripe (procesar eventos)
     - GET /api/user/{phone}/premium (verificar estado)

   Variables de entorno:
     - STRIPE_SECRET_KEY
     - STRIPE_WEBHOOK_SECRET

   Testing:
     - Usar Stripe CLI para webhooks locales
     - Test cards de Stripe

2. ‚ùå Paywall funcional:
   Tiempo estimado: 1 d√≠a
   Ubicaci√≥n: Bloquear en /api/session/{id}/ocr o /upload

   L√≥gica:
     ```python
     user = Database.get_or_create_user(phone)
     if not user.is_premium and user.free_bills_used >= 1:
         raise HTTPException(402, {"detail": "Upgrade required"})
     ```

   Frontend:
     - Detectar HTTP 402
     - Mostrar pantalla de upgrade
     - Bot√≥n "Pagar ${variant.price}/a√±o"
     - Redirect a Stripe Checkout

3. ‚ùå Tracking de uso:
   Tiempo estimado: 1 d√≠a
   Cambios:
     - Incrementar free_bills_used en cada uso
     - Incrementar total_bills_divided
     - Registrar ConversionEvent

   Endpoints analytics:
     - GET /api/analytics/ab-test
     - GET /api/analytics/conversions

IMPORTANTE (Aumenta adopci√≥n):

4. ‚ö†Ô∏è WhatsApp activado:
   Tiempo estimado: 1 d√≠a
   Pasos:
     - Crear app en Meta for Developers
     - Configurar WhatsApp Business API
     - Obtener tokens
     - Configurar webhook en Meta
     - Agregar env vars en Render
     - Probar con n√∫mero de prueba

   Beneficio: Canal de adquisici√≥n org√°nico

5. ‚ùå Landing page:
   Tiempo estimado: 2-3 d√≠as
   Contenido:
     - Hero con value proposition
     - Demo en video/GIF
     - Features list
     - Pricing
     - FAQ
     - CTA: "Prueba gratis" o WhatsApp

   Tecnolog√≠a: Puede ser mismo React app (ruta /)

   Beneficio: Conversi√≥n de tr√°fico org√°nico

NICE-TO-HAVE (Mejora UX):

6. ‚ùå Historial de cuentas:
   - Requiere: Base de datos persistente (PostgreSQL)
   - Guardar sesiones completadas
   - Ver cuentas pasadas
   - Re-usar configuraciones

7. ‚ùå Exportar a PDF:
   - Generar PDF con resumen
   - Enviar por email/WhatsApp
   - Logo personalizable

8. ‚ùå Modo grupo:
   - Link √∫nico para grupo
   - Cada persona se agrega a s√≠ misma
   - Ve su parte en tiempo real

--------------------------------------------------------------------------------
9.4. PR√ìXIMOS PASOS RECOMENDADOS
--------------------------------------------------------------------------------

SEMANA 1 - Monetizaci√≥n:
  D√≠a 1-2: Integrar Stripe
    - Crear cuenta Stripe
    - Implementar checkout endpoint
    - Implementar webhook
    - Testear con tarjetas de prueba

  D√≠a 3: Implementar paywall
    - L√≥gica backend
    - Componente frontend
    - Flow completo de upgrade

  D√≠a 4: Testing end-to-end
    - Flujo completo: uso gratis ‚Üí paywall ‚Üí pago ‚Üí premium
    - Validar que premium_until funciona
    - Verificar A/B testing

  D√≠a 5: Deploy y monitoreo
    - Deploy a producci√≥n
    - Configurar alertas de Stripe
    - Monitorear primeras conversiones

SEMANA 2 - Canales de Adquisici√≥n:
  D√≠a 1: Activar WhatsApp
    - Configurar Meta app
    - Obtener tokens
    - Configurar webhook
    - Probar flujo completo

  D√≠a 2-3: Landing page
    - Dise√±o simple
    - Copywriting
    - CTA claro
    - Deploy

  D√≠a 4-5: Marketing inicial
    - Post en redes sociales
    - Mensaje a amigos/familia
    - Grupos de emprendedores chilenos
    - Reddit/HackerNews (si aplica)

SEMANA 3 - Optimizaci√≥n:
  - Analizar m√©tricas de A/B test
  - Optimizar conversion rate
  - Mejorar UX seg√∫n feedback
  - Agregar analytics (Google Analytics, Mixpanel)

SEMANA 4 - Escala:
  - Automatizar marketing
  - Content marketing (blog posts)
  - SEO optimization
  - Partnerships con restaurants

--------------------------------------------------------------------------------
9.5. M√âTRICAS DE √âXITO
--------------------------------------------------------------------------------

M√âTRICAS CLAVE (KPIs):

Adquisici√≥n:
  - Usuarios nuevos/semana
  - Fuente de tr√°fico (WhatsApp, web, referidos)
  - Bounce rate en landing

Activaci√≥n:
  - % que completan primera divisi√≥n
  - Tiempo promedio en app
  - Tasa de error en OCR

Retenci√≥n:
  - % que regresa para segunda cuenta
  - D√≠as hasta segundo uso
  - % que llega al paywall

Monetizaci√≥n:
  - Conversion rate (paywall ‚Üí pago)
  - Revenue por variante de precio
  - Churn rate de premium

Referidos:
  - % que comparte link
  - Usuarios por referido

OBJETIVOS MES 1:
  - 100 usuarios √∫nicos
  - 150 cuentas divididas
  - 10 conversiones (10% CR)
  - $15-25 en revenue
  - Identificar variante ganadora

OBJETIVOS MES 3:
  - 500 usuarios √∫nicos
  - 800 cuentas divididas
  - 60 conversiones (12% CR)
  - $90-150 en revenue
  - Optimizar flujo de conversi√≥n

OBJETIVOS MES 6:
  - 2000 usuarios √∫nicos
  - 3500 cuentas divididas
  - 300 conversiones (15% CR)
  - $450-750 en revenue
  - Canal de marketing escalable

--------------------------------------------------------------------------------
9.6. RIESGOS Y MITIGACI√ìN
--------------------------------------------------------------------------------

RIESGOS T√âCNICOS:

1. OCR tiene baja precisi√≥n:
   Mitigaci√≥n:
     - Permitir edici√≥n manual de todos los campos
     - Agregar instrucciones para tomar foto clara
     - Probar con m√∫ltiples tipos de boletas
     - Considerar usar GPT-4 Vision como backup

2. Render free tier spin down:
   Mitigaci√≥n:
     - Mostrar mensaje "Cargando..." en frontend
     - Implementar retry logic
     - Upgrade a Starter ($7/mes) si hay tr√°fico constante
     - Considerar Railway o Fly.io como alternativa

3. L√≠mite de Redis free tier:
   Mitigaci√≥n:
     - Monitorear uso diario
     - Reducir TTL si es necesario
     - Limpiar sesiones expiradas manualmente
     - Upgrade a pay-as-you-go si es necesario

RIESGOS DE NEGOCIO:

1. Baja conversi√≥n (<5%):
   Mitigaci√≥n:
     - A/B test de precios m√°s agresivo
     - Ofrecer descuentos temporales
     - Mejorar value proposition
     - Agregar features premium

2. Alto churn de premium:
   Mitigaci√≥n:
     - Email de renovaci√≥n con descuento
     - Agregar m√°s valor (historial, reportes)
     - Ofrecer plan mensual adem√°s de anual
     - Programa de referidos

3. Competencia:
   Mitigaci√≥n:
     - Ser el primero en mercado chileno
     - Integraci√≥n con WhatsApp como diferenciador
     - UX superior
     - Pricing competitivo

RIESGOS OPERACIONALES:

1. Abuso del free tier:
   Mitigaci√≥n:
     - Rate limiting por IP
     - Captcha en creaci√≥n de sesi√≥n
     - Detectar patrones sospechosos
     - Ban de IPs maliciosas

2. Costos de OCR altos:
   Mitigaci√≥n:
     - Google Vision: 1000 gratis/mes
     - Despu√©s: $1.50/1000 im√°genes
     - Cachear resultados cuando sea posible
     - Considerar Tesseract (open source) como alternativa

3. Soporte al cliente:
   Mitigaci√≥n:
     - FAQ completo
     - Mensajes de error claros
     - Email de soporte
     - Automatizar respuestas comunes

--------------------------------------------------------------------------------
9.7. VENTAJAS COMPETITIVAS
--------------------------------------------------------------------------------

DIFERENCIADORES:

1. ‚úÖ OCR Autom√°tico:
   - Competidores: Entrada manual de items
   - Bill-e: Foto ‚Üí extracci√≥n autom√°tica
   - Ahorro de tiempo: ~2-3 minutos por cuenta

2. ‚úÖ Propina Proporcional:
   - Competidores: Divisi√≥n equitativa o manual
   - Bill-e: Propina proporcional al consumo
   - M√°s justo y matem√°ticamente correcto

3. ‚ö†Ô∏è WhatsApp Integration (pr√≥ximamente):
   - Competidores: Solo web
   - Bill-e: WhatsApp + web
   - Menor fricci√≥n, m√°s viral

4. ‚úÖ Pricing Competitivo:
   - Competidores: $3-5/mes o $30-50/a√±o
   - Bill-e: $1-2/a√±o
   - 10-20x m√°s barato

5. ‚úÖ Localizaci√≥n Chilena:
   - Formato de n√∫meros chileno
   - OCR entrenado para boletas chilenas
   - Pesos chilenos nativos

6. ‚úÖ Sin fricci√≥n:
   - No requiere registro
   - No requiere app
   - Solo link temporal

7. ‚úÖ UX Superior:
   - Interfaz limpia
   - Responsive
   - Tiempo real
   - Edici√≥n f√°cil

BARRERAS DE ENTRADA:

1. T√©cnicas:
   - OCR bien implementado requiere expertise
   - Integraci√≥n WhatsApp tiene curva de aprendizaje
   - Parser de boletas requiere muchas iteraciones

2. Operacionales:
   - First-mover advantage en Chile
   - Base de usuarios early adopters
   - Feedback loop de mejora

3. De marketing:
   - Viralidad built-in (compartir link)
   - WhatsApp como canal de distribuci√≥n
   - Boca a boca

--------------------------------------------------------------------------------
9.8. CONCLUSI√ìN
--------------------------------------------------------------------------------

ESTADO: ‚úÖ MVP t√©cnicamente funcional, listo para monetizaci√≥n

FORTALEZAS:
  ‚úÖ C√≥digo limpio y bien estructurado
  ‚úÖ OCR funcionando correctamente
  ‚úÖ UX pulida y responsive
  ‚úÖ Infraestructura escalable (Redis, Render, Vercel)
  ‚úÖ Costos de operaci√≥n = $0 (free tiers)

DEBILIDADES:
  ‚ùå No hay monetizaci√≥n implementada (Stripe falta)
  ‚ùå No hay tracking de conversiones
  ‚ùå WhatsApp no activado en producci√≥n
  ‚ùå No hay landing page
  ‚ùå Credenciales de Google expuestas en repo

OPORTUNIDADES:
  ‚úÖ Mercado chileno sin competidor directo
  ‚úÖ Modelo de negocio validado (Splitwise, Settle Up)
  ‚úÖ Canal de distribuci√≥n viral (WhatsApp)
  ‚úÖ Bajo CAC esperado (viralidad)

AMENAZAS:
  ‚ö†Ô∏è Competidores pueden copiar r√°pidamente
  ‚ö†Ô∏è Dependencia de servicios externos (Google, Stripe)
  ‚ö†Ô∏è Cambios en WhatsApp API pricing

RECOMENDACI√ìN FINAL:
  1. URGENTE: Rotar credenciales de Google Cloud
  2. PRIORIDAD 1: Implementar Stripe (1 semana)
  3. PRIORIDAD 2: Activar WhatsApp (1 d√≠a)
  4. PRIORIDAD 3: Landing page (3 d√≠as)
  5. LAUNCH: Soft launch con amigos/familia
  6. ITERAR: Basado en feedback y m√©tricas

TIEMPO HASTA LAUNCH:
  - Optimista: 1-2 semanas (solo Stripe)
  - Realista: 3-4 semanas (Stripe + WhatsApp + Landing)
  - Conservador: 6-8 semanas (todo + testing + marketing)

POTENCIAL:
  - Mercado: 19M personas en Chile
  - TAM: ~5M que salen a comer regularmente
  - SAM: ~500K early adopters de tech
  - SOM: ~10K en primer a√±o (2% de SAM)
  - Revenue a√±o 1: $15-20K USD (10K √ó $1.50 √ó 10% CR)

¬°El proyecto est√° en excelente estado t√©cnico y listo para el siguiente paso!

================================================================================
FIN DEL AN√ÅLISIS
================================================================================
